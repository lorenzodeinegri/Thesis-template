% !TEX encoding = UTF-8
% !TEX TS-program = pdflatex
% !TEX root = ../tesi.tex

%**************************************************************
\chapter{Tecnologie e strumenti}
\label{cap:tecnologie-strumenti}

%**************************************************************
\section{Tecnologie}
\subsection{Commercio.network}

\textit{Commercio.network}\footcite{site:commercio-network} è un progetto \gls{open-sourceg} che punta a dare alle aziende la possibilità di firmare e scambiare documenti commerciali con valenza legale, sia di tipo strutturato che di tipo non strutturato, utilizzando la tecnologia \gls{blockchaing}, in modo da garantirne:

\begin{itemize}
	\item la paternità, ossia assicurare che il documento sia stato effettivamente creato e inviato da chi dichiara di averlo fatto;
	\item il non ripudio, ossia impedire al creatore e mittente del documento di negare di averlo firmato digitalmente;
	\item l'integrità, ossia certificare che il documento non sia stato in alcun modo alterato durante il trasporto dal mittente al destinatario.
\end{itemize}

Per ridurre la complessità di implementazione ed utilizzo di una \gls{blockchaing}, il progetto prevede la definizione di tre livelli \textit{software}, ciascuno con degli specifici compiti da portare a termine:

\begin{itemize}
	\item livello applicazione, attraverso il quale possono essere implementate delle applicazioni che sfruttano la \textit{Commercio.network} per raggiungere i loro scopi;
	\item livello di rete, tramite cui le aziende possono eseguire il \textit{software} che realizza un nodo della rete;
	\item livello di protocollo, per mezzo del quale vengono sviluppate le nove funzionalità base che Commerc.io S.r.l. punta a fornire tramite il proprio progetto.
\end{itemize}

\subsubsection*{Nodi}

Un nodo è un macchina \textit{server} che esegue il \textit{software} creato da Commerc.io S.r.l. che consente l'interazione con la \gls{blockchaing} e con gli altri nodi della rete tramite essa. Esistono due diversi tipi di nodi, i nodi completi e i nodi validatori.\\
Un nodo completo ha il compito di mantenere in memoria tutto lo storico delle transazioni effettuate sulla \gls{blockchaing}, per fare questo è necessario che il nodo resti sempre connesso alla \textit{Commercio.network} e, ogni qual volta viene aggiunto un nuovo blocco, questo deve essere salvato nella propria memoria locale.\\
Un nodo validatore è un nodo completo a cui è stata data la capacità di validare le nuove transazioni che devono essere aggiunte alla \gls{blockchaing}. Per fare ciò, ogni validatore possiede una propria chiave crittografica privata che utilizza per firmare le transazioni che intende marcare come valide. In cambio delle risorse messe a disposizione per svolgere il lavoro di validazione, questi nodi percepiscono una ricompensa per ogni nuovo blocco aggiunto alla \gls{blockchaing}.

\subsubsection*{Consenso}

Il meccanismo di consenso distribuito utilizzato dalla \textit{Commercio.network} è il \gls{pos}, il quale prevede l'utilizzo di un algoritmo casuale per arrivare alla determinazione del prossimo nodo che avrà la possibilità di creare il nuovo blocco successivo all'ultimo aggiunto alla \gls{blockchaing}.\\
Non tutti i nodi della rete possono essere selezionati per la generazione del nuovo blocco, ma solo i nodi validatori. Per diventare tale, un nodo deve accumulare e mettere in stato di fermo una sufficiente quantità di \gls{tokeng} per un certo periodo di tempo. In questo modo è possibile mantenere alto il valore dei \gls{tokeng} stessi e, per prevenire azioni speculative da parte dei nodi validatori, atte solamente a accumulare criptovaluta, sono stati introdotti dei tagli automatici al numero di \gls{tokeng} posseduti in caso di prolungata inattività o per comportamenti scorretti.

\subsubsection*{Finalità}

Dato lo scopo per cui è stata realizzata, la \textit{Commercio.network} prevede la finalità istantanea per tutti i nuovi blocchi che vengono creati e aggiunti alla \gls{blockchaing}; infatti, trattandosi di scambio di documenti commerciali con valenza legale, le aziende che eseguono delle transazioni vogliono avere la certezza che una volta effettuate queste non possano più essere modificate o eliminate.\\
Di conseguenza, è stato progettato un protocollo di consenso che tenesse in considerazione questo fattore e consentisse di ottenere la finalità istantanea per ogni nuova transazione, con un intervallo di blocco di cinque secondi. In particolare, per essere finalizzato, ogni blocco proposto per essere aggiunto alla \gls{blockchaing} deve ricevere l'approvazione, tramite votazione, di almeno due terzi di tutti i nodi validatori presenti; solo dopo aver raggiunto questo \textit{quorum} il nodo validatore designato potrà validare il blocco ed aggiungerlo alla \gls{blockchaing}, rendendolo finale. Questo processo continua all'infinito finché un terzo o più del totale dei nodi validatori diventa inattivo: in questo caso tutta la rete si blocca in quanto non è più possibile approvare nuovi blocchi. 

\subsubsection*{Token}

La \textit{Commercio.network} possiede una propria criptovaluta nativa che viene utilizzata sia per favorire la gestione dei nodi della rete da parte degli utenti, sia per incentivare gli utenti stessi ad invitarne di nuovi. Attraverso questo \gls{tokeng} tutti i partecipanti alla rete possono trarre beneficio dalla crescita di quest'ultima, in quanto la criptovaluta ne rappresenta il valore. In questo modo vengono allineati tutti i particolari interessi degli utenti e indirizzati verso la collaborazione per favorire lo sviluppo della rete.\\
Questa criptovaluta viene quindi utilizzata per incentivare la gestione e la partecipazione attiva nella rete da parte dei nodi validatori, infatti per ogni nuovo blocco validato ogni nodo percepisce un certo ammontare di \gls{tokeng}, al contrario, se questo rimane inattivo per troppo tempo viene automaticamente rimosso un certo ammontare di criptovaluta dal proprio \gls{walletg}. Invece, per favorire la crescita della rete sono previsti degli incentivi economici, sotto forma di un certo numero di \gls{tokeng}, che vengono erogati a tutti gli utenti che hanno fatto sì che un altro utente entrasse a far parte della \textit{Commercio.network}. Infatti l'unico modo per poter partecipare alla rete è tramite invito da parte di un membro della rete stessa.\\\\
La criptovaluta presente all'interno della \gls{blockchaing} è chiamata \gls{com}\glsfirstoccur{} e il suo controvalore in valuta legale viene determinato dal mercato, in base al valore intrinseco della rete, che può avere quindi delle fluttuazioni. Sebbene possa essere scambiata con altre criptovalute o con monete a corso legale, il suo scopo principale è fornire un'unità di valore da poter mettere in stato di fermo da parte di un nodo per poter diventare un validatore. Secondariamente, può essere utilizzata come garanzia per la generazione di una seconda criptovaluta, chiamata \gls{ccc}\glsfirstoccur, la quale è progettata per essere una moneta stabile, ossia un \gls{tokeng} che mantiene fisso il suo controvalore in valuta a corso legale, pari ad un euro, senza subire alcuna fluttuazione in base all'andamento del mercato.\\
I \gls{ccc} sono stati ideati per essere utilizzati come metodo di pagamento all'interno della \gls{blockchaing}, in modo che le aziende che vi partecipano non debbano essere costrette ad operare con criptovalute che subiscono le fluttuazioni del mercato. Questi \gls{tokeng} sono usati per il pagamento delle transazioni da parte di chi le effettua, ognuna di esse ha il costo di un centesimo di \gls{ccc} e quindi un centesimo di euro. Come i \gls{com}, possono essere scambiati con altre criptovalute oppure con monete legali.

\subsubsection*{Reti}

La \textit{Commercio.network} non consiste di un'unica \gls{blockchaing}, in realtà mette a disposizione degli utenti due reti distinte che, pur funzionando allo stesso modo e utilizzando il medesimo algoritmo per il consenso distribuito, non sono né interscambiabili né interoperabili. In particolare hanno due diversi blocchi iniziali e utilizzano \gls{tokeng} differenti, anche se svolgono la stessa funzione all'interno della relativa \gls{blockchaing}.\\
La prima rete è chiamata \textit{Testnet} ed è pensata per essere utilizzata solamente per fare dei test di funzionamento prima passare alla rete vera e propria, la \textit{Mainnet}. Infatti i \gls{tokeng} utilizzati al suo interno non hanno alcun valore economico e sono disponibili in quantità illimitata, in questo modo è possibile provare qualsiasi operazione per un numero arbitrario di volte, senza alcun costo, oltre a non correre nessun rischio in caso di errori o compromissioni della \gls{blockchaing}. Inoltre, sempre al fine di poter fare più test possibile, sulla \textit{Testnet} è possibile eseguire sia un nodo completo che un nodo validatore senza il bisogno di accumulare dei \gls{tokeng}\\
La seconda rete, invece, è chiamata \textit{Mainnet} e costituisce la \gls{blockchaing} principale, dove la criptovaluta emessa ha un effettivo valore economico e viene utilizzata per scopi di produzione delle aziende partecipanti.

\subsection{Macchina virtuale}

Una macchina virtuale è un \textit{software} che realizza un'emulazione di una macchina fisica attraverso un processo di virtualizzazione, attraverso il quale le risorse \textit{hardware} del dispositivo vengono astratte e rese disponibili al \textit{software} sotto forma virtuale. Di conseguenza non viene fatto accesso e non vengono utilizzate direttamente le risorse fisiche del calcolatore, bensì una loro emulazione logica. Una volta creata una macchina virtuale, su di essa è possibile installare un sistema operativo e delle applicazioni, tramite la stessa procedura che si segue per fare queste operazioni su una macchina fisica.\\
Questa tecnica è usata principalmente per ottimizzare l'utilizzo delle risorse fisiche di un calcolatore, permettendo l'esecuzione contemporanea di più sistemi virtualizzati che svolgono diverse operazioni. Inoltre la virtualizzazione permette di creare sistemi che, essendo slegati dall'\textit{hardware}, non possono in alcun modo causare dei danni al sistema operativo ospitante, anche in caso di corruzione della propria memoria e/o dei propri dischi.\\
Nel progetto di stage è stata utilizzata una macchina virtuale apposita per l'installazione e l'esecuzione di un nodo della rete \textit{Commercio.network}. Così facendo è stato possibile usare la stessa macchina fisica sia per sviluppare e testare il \gls{poc}, all'interno del sistema operativo installato sull'\textit{hardware} reale, sia per interagire con la \gls{blockchaing} di Commerc.io S.r.l., eseguendo tutti i \textit{software} necessari a ciò dentro al sistema virtuale. Solo in questo modo si è potuto mantenere in esecuzione il nodo della rete e, contemporaneamente, avviare ed utilizzare l'applicazione implementata, questa infatti aveva bisogno di accedere alla \gls{blockchaing} per svolgere correttamente tutte le operazioni rese disponibili all'utente.

\subsection{Git}

Git\footcite{site:git} è un sistema \gls{open-sourceg} per il controllo del versionamento distribuito che permette di tracciare tutte le modifiche fatte al codice durante lo sviluppo \textit{software}. È progettato per favorire il coordinamento tra diversi programmatori che lavorano allo stesso progetto, apportando modifiche allo stesso sorgente da macchine differenti; tuttavia può essere utilizzato per mantenere lo storico dei cambiamenti fatti in qualsiasi insieme di file, non necessariamente codice di un qualche linguaggio di programmazione. È stato realizzato per essere molto veloce in termini di prestazioni e per assicurare l'integrità dei dati gestiti in ogni momento durante il suo utilizzo, inoltre supporta diverse tipi di flussi di lavoro, compresi quelli distribuiti e non lineari.\\
Ogni cartella gestita tramite Git, su qualsiasi \textit{computer}, mantiene lo storico completo di tutte le aggiunte, modifiche e rimozioni fatte ai file in essa contenuti; inoltre, dispone di tutte le funzionalità di tracciamento della versione, indipendentemente dallo stato della connessione di rete verso un \textit{server} centrale.\\
Nel progetto di stage è stato utilizzato per poter fare un corretto versionamento del codice scritto per implementare il \gls{poc} richiesto, oltre a questo è stato sfruttato anche per semplificare lo sviluppo del progetto \textit{software} tra più macchine differenti.

\subsection{Dart}

Dart\footcite{site:dart} è un linguaggio di programmazione lato \textit{client} sviluppato da Google e ottimizzato per l'implementazione di applicazioni multi-piattaforma, tra cui dispositivi mobili, \textit{computer desktop}, \textit{server} e \textit{web}; questo è reso possibile grazie all'utilizzo di un'apposita macchina virtuale che livella le particolarità dei diversi ambienti di sviluppo ed esecuzione. È un linguaggio orientato agli oggetti, basato sul concetto di classe e che fornisce un meccanismo per la gestione automatica della memoria (\textit{garbage collector}). Ha una sintassi derivata dal linguaggio C e supporta più paradigmi di programmazione: imperativo, orientato agli oggetti, funzionale e riflessivo. Per eseguire un \textit{software} scritto in Dart è necessario compilare il codice per generarne il corrispondente eseguibile, tuttavia il linguaggio permette due diverse tipologie di compilazione: la prima che permette di trasformare il sorgente in codice macchina nativo, mentre la seconda consente la conversione dello stesso in codice JavaScript equivalente, anch'esso pronto per essere eseguito.\\
Durante lo stage è stato scelto come linguaggio da usare per l'implementazione del \gls{poc} in quanto, sebbene sia molto recente e non ancora largamente diffuso, offre le stesse funzionalità dei linguaggi maggiormente consolidati; questo, combinato con la semplicità di apprendimento ed utilizzo e, soprattutto, con la grande portabilità che garantisce tramite l'impiego della propria macchina virtuale, lo rendono ideale per soddisfare le necessità dell'azienda.

\subsection{Flutter}

Flutter\footcite{site:flutter} è un \gls{sdk}\glsfirstoccur{} \gls{open-sourceg} per lo sviluppo di interfacce grafiche creato da Google e ottimizzato per l'implementazione di programmi multi-piattaforma a partire da un singolo codice sorgente comune. In particolare permette di realizzare applicazioni per Android, iOS, Linux, Mac, Windows e anche per web.\\
L'architettura del \gls{frameworkg}\glsfirstoccur{} si basa sui seguenti componenti, che ne costituiscono le fondamenta:

\begin{itemize}
	\item Piattaforma Dart;
	\item Motore Flutter;
	\item Libreria di base;
	\item Componenti grafici specifici per il \textit{design}.
\end{itemize}

Le applicazioni Flutter sono scritte utilizzando il linguaggio di programmazione Dart, di cui vengono sfruttate molte funzionalità avanzate. Tramite la macchina virtuale su cui viene eseguito il \gls{frameworkg}, è possibile usufruire della compilazione \gls{jit}\glsfirstoccur{} che fornisce allo sviluppatore l'opportunità di usare l'\textit{hot reload} durante le fasi di scrittura e test dell'applicazione. Questo meccanismo prevede l'iniezione delle modifiche fatte al codice sorgente direttamente all'interno del \textit{software} in esecuzione, in questo modo verranno subito riflesse all'interno dell'applicazione senza richiederne la ricompilazione e il riavvio. Tuttavia è presente anche una compilazione \gls{aot}\glsfirstoccur{} che permette di ottenere eseguibili con elevate prestazioni, anche su dispositivi mobili.
\\\\
Il motore Flutter è scritto con il linguaggio di programmazione C++ e fornisce il supporto per effettuare le operazioni di \textit{rendering} della grafica a basso livello, inoltre funge da interfaccia verso le \gls{sdk} specifiche della piattaforma di esecuzione, come Android e iOS. Oltre a questo, implementa tutte le librerie che formano il nucleo del \gls{frameworkg} Flutter, fornendo le funzionalità necessarie per le animazioni, per la grafica, per le operazioni di \textit{input/output} e per il supporto all'accessibilità. Questo motore rappresenta quindi l'ambiente di esecuzione per le applicazioni scritte in Flutter.
\\\\
Oltre alle librerie centrali del \gls{frameworkg}, è presente una libreria di base che contiene tutte le classi e le funzioni necessarie per la costruzione di applicazioni, tra cui anche quelle per accedere e comunicare con il motore Flutter.
\\\\
Flutter fornisce due insiemi distinti di elementi grafici che possono essere utilizzati per la realizzazione delle interfacce, questi reimplementano, il primo i componenti sviluppati da Google per il sistema operativo Android, il secondo quelli costruiti da Apple per il sistema operativo iOS.
\\\\
Nel progetto di stage è stato scelto di utilizzare questo \gls{frameworkg} in quanto permette di creare la stessa applicazione, sia per dispositivi mobili Android che per dispositivi mobili iOS, scrivendone il codice solamente una volta. Questo è stato ritenuto estremamente importante da parte dell'azienda per la realizzazione del \gls{poc}, in quanto avrebbe permesso di dimezzare i tempi di sviluppo richiesti.

%**************************************************************
\section{Strumenti}
\subsection{VirtualBox}

VirtualBox\footcite{site:virtual-box} è un \textit{software} \gls{open-sourceg} sviluppato da Oracle che fornisce le funzionalità di creazione, controllo ed esecuzione di macchine virtuali ospiti all'interno del sistema operativo del proprio dispositivo fisico. Permette di caricare più sistemi ospiti su un singolo sistema ospitante, ognuno di questi può essere gestito indipendentemente dagli altri, all'interno della propria macchina virtuale. Inoltre, sistema ospitato e sistema ospitante possono comunicare tra di loro sia tramite memoria condivisa che tramite schede di rete virtuali. Infine, supporta sia la virtualizzazione basata su \textit{software} che quella basata su \textit{hardware}, cercando sempre di prediligere quest'ultima alla prima, in quanto più performante.\\
Nel progetto di stage è stato utilizzato per gestire la macchina virtuale necessaria per l'installazione e l'esecuzione di un nodo della \textit{Commercio.network}.

\subsection{Ubuntu}

Ubuntu\footcite{site:ubuntu} è un sistema operativo \gls{open-sourceg} basato su Debian, una distribuzione di Linux. Si tratta di un sistema semplice da installare, tramite una procedura guidata, e da utilizzare, attraverso un'intuitiva interfaccia grafica; tuttavia offre molti strumenti utili agli sviluppatori \textit{software}, come gestori di pacchetti, compilatori e ambienti di sviluppo. Inoltre, fa uso di molte tecniche di sicurezza informatica per prevenire il più possibile attacchi sia dall'esterno che dall'interno del sistema. A tal fine prevede una sofisticata gestione dei permessi degli utenti, un controllo totale della connessione e del traffico in rete, e dei compilatori che fanno utilizzo di meccanismi di protezione della memoria. \\
È stato scelto per essere installato all'interno della macchina virtuale utilizzata nel progetto di stage in quanto, tra i sistemi operativi supportati dal \textit{software} che implementa un nodo della rete \textit{Commercio.network}, era quello più adatto ad essere contenuto all'interno dei un ambiente virtuale, sia per la leggerezza in termini di sfruttamento delle risorse, che per la grande capacità di personalizzazione e adattamento.

\subsection{Cnd}

Cnd è un demone \textit{software}, ossia un programma che, una volta lanciato, resta in esecuzione in \textit{background} senza fornire nessuna possibilità di interazione attiva all'utente. Solitamente questi \textit{software} vengono utilizzati come servizi del sistema operativo e vengono avviati automaticamente durante l'accensione del sistema stesso.\\
Cnd è il \textit{software} sviluppato da Commerc.io S.r.l. per l'implementazione di un nodo della rete \textit{Commercio.network}, è possibile installarlo facilmente seguendo la procedura presente nella documentazione ufficiale\footcite{manual:docs-commercio-network} e, una volta avviato, gestire automaticamente tutte le operazioni necessarie per il corretto funzionamento del nodo e per la corretta interazione con la \gls{blockchaing} in modo da eseguire le operazioni richieste. Oltre a questo, implementa anche un \textit{web server} \gls{rest}\glsfirstoccur{} interrogabile sia dal sistema operativo dove viene eseguito che da dispositivi esterni collegati in rete con esso; è quindi possibile servirsi di questo per operare sulla rete \textit{Commercio.network}.\\
Nel progetto di stage è stato installato all'interno della macchina virtuale Linux per poter poi sfruttarlo per utilizzare la \gls{blockchaing} per la realizzazione delle funzionalità previste per il \gls{poc}. 

\subsection{Cncli}

Cncli è il software sviluppato da Commerc.io S.r.l. per l'implementazione di un'interfaccia a riga di comando per eseguire operazioni tramite un nodo della rete \textit{Commercio.network} attraverso il demone \textit{software} Cnd. Viene automaticamente installato seguendo la procedura per l'installazione di Cnd e, utilizzandolo dal terminale del sistema operativo, è possibile inserire degli appositi comandi che verranno interpretati e porteranno all'esecuzione di specifiche operazioni sulla \gls{blockchaing} tramite il nodo della rete.\\
Durante il progetto è stato usato, all'interno della macchina virtuale, per testare il funzionamento della \textit{Commercio.network} in base gli scopi dello stage, prima di sviluppare il \gls{poc}. 

\subsection{Nginx}

Nginx\footcite{site:nginx} è un \textit{software} \gls{open-sourceg} sviluppato da Nginx Inc. che realizza un \textit{web server}. Oltre a questo, può essere anche sfruttato per fare \textit{reverse proxying}, ossia il reindirizzamento delle richieste di un \textit{client} verso uno o più \textit{server} e delle risposte del singolo server verso il \textit{client} opportuno; bilanciamento del carico di richieste dei \textit{client} verso più \textit{server}; \textit{web caching}, ossia la memorizzazione temporanea di pagine \textit{web} recentemente accedute, in modo da reperirle più velocemente per rispondere ad altre richieste successive.\\
Nel progetto di stage è stato utilizzato all'interno della macchina virtuale Linux per esporre all'esterno della stessa le \gls{api} \gls{rest} fornire dal nodo della rete \textit{Commercio.network}; il \textit{server web} eseguito al suo interno, infatti, resta in ascolto per eventuali richieste solamente sull'indirizzo locale del sistema. Tramite la funzionalità di \textit{reverse proxy} di Nginx, quindi, è stato possibile realizzare un reindirizzamento delle richieste fatte all'indirizzo di rete della macchina virtuale, da parte di un dispositivo esterno, verso il \textit{web server} eseguito dal nodo.

\subsection{GitHub}

GitHub\footcite{site:github} è servizio che permette agli utenti di far ospitare, sulla sua piattaforma \textit{online}, i propri progetti \textit{software}. Fornisce strumenti di sviluppo come il controllo del versionamento distribuito e la gestione del codice sorgente, utilizzando Git, oltre che una serie di altre funzionalità proprie; tra queste si possono trovare sistemi per il controllo d'accesso, per il tracciamento degli errori, per la richiesta di nuove funzionalità e per la gestione dei compiti da svolgere all'interno di un progetto.\\
GitHub offre diversi piani tariffari in base alle funzionalità che si vuole utilizzare, tuttavia, per lo scopo dello stage, è stato sufficiente servirsi del servizio gratuito, in quanto era necessario predisporre un solo progetto privato, senza alcun collaboratore. Infatti la piattaforma è stata utilizzata solamente per effettuare il tracciamento dello sviluppo del codice sorgente del \gls{poc} e il progredire delle sue versioni durante il corso del progetto.

\subsection{PowerShell}

PowerShell\footcite{site:powershell} è un \gls{frameworkg} per l'automatizzazione e la gestione delle configurazioni e dei compiti presenti all'interno del sistema operativo. Consiste di una interfaccia a linea di comando, attraverso la quale l'utente può eseguire diverse operazioni, allo stesso modo che con il terminale di sistema.\\
Nel progetto di stage è stato utilizzato per installare e gestire tutti i \textit{software} necessari per lo sviluppo del \gls{poc}.

\subsection{Android Studio}

Android Studio\footcite{site:android-studio} è un ambiente di sviluppo software integrato, specificamente progettato per la realizzazione di applicazioni per dispositivi mobili con sistema operativo Android. È stato costruito sulla base di IntelliJ IDEA, un ambiente di sviluppo per i linguaggi Java e Kotlin creato da JetBrains, un'azienda specializzata nella produzione di ambienti di sviluppo integrati per tutti i linguaggi di programmazione più diffusi.\\
Basandosi su IntelliJ, Android Studio ne eredita la maggior parte delle funzionalità, come ad esempio il processo di costruzione dell'applicativo bastato su Gradle, gli strumenti per l'autogenerazione e l'autocorrezione del codice sorgente, e quelli per il rilevamento di problemi di prestazioni, usabilità e compatibilità. Oltre a questo, implementa dei \textit{software} ausiliari per facilitare lo sviluppo delle applicazioni Android, tra questi i più rilevanti sono il generatore di componenti grafici, il visualizzatore dell'anteprima del \textit{layout} dell'interfaccia grafica realizzata e l'emulatore Android che permette di creare un dispositivo virtuale per l'esecuzione e il test delle applicazioni senza necessita di utilizzarne uno fisico.\\
Android Studio è pensato per effettuare delle implementazioni che utilizzano solamente i linguaggi Java o Kotlin, tuttavia mette a disposizione dello sviluppatore una vasta gamma di espansioni che ne espandono le funzionalità. Per il progetto di stage, infatti, è stata prevista la realizzazione di un \gls{poc} in linguaggio Dart tramite il \gls{frameworkg} Flutter; a tal fine sono state installati gli opportuni pacchetti per consentire l'estensione delle funzioni base dell'ambiente di sviluppo anche al codice scritto in Dart/Flutter.
